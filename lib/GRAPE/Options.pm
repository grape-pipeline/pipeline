package GRAPE::Options;

use strict;
use warnings;
use Getopt::Long;
use Cwd;


use vars qw($AUTOLOAD);
use GRAPE::DBinterface qw(MySQL_DB_Connect check_field_value);

##################################################
## This should manage the options generated by the start script
##################################################
sub new {
    my $class =shift;
    
    my $self  = {};
    bless($self,$class);
    
    my %options;
    my $success=GetOptions(\%options,
			   'species|s=s',
			   'project=s',
			   'experiment=s',
			   'clean',
			   'help|h',
			   'man',
			   'debug|d+',
			   'template|t=s',
			   'annotation|a=s',
			   'genome|g=s',
			   'files=s',
			   'host=s',
			   'commondb=s',
			   'database=s',
			   'geneclass=s',
			   'transclass=s',
			   'junctionstable=s',
			   'junctionsclass=s',
			   'exonsclass=s',
			   'mismatches=i',
			   'paired',
			   'stranded',
			   'readlength=i',
			   'mapper=s',
			   'threads=i',
			   'genomeindex=s',
			   'transcriptomeindex=s',
			   'junctionsindex=s',
			   'exclusionfile=s',
			   'localdir=s',
			   'cluster=s',
			   'qualities=s',
			   'cellline=s',
			   'compartment=s',
			   'run_description=s',
			   'projdesc=s',
			   'rnafrac=s',
			   'bioreplicate=s',
			   'preprocess=s',
			   'preprocess_trim_length=s',
			   'fluxmem=i'
	);

    # Determine if the options were all read correctly
    $self->set_OptionsOK($success);

    # Initialize the options that need to be present with the provided values or
    # reasonable defaults if they are missing
    $self->_initialize(\%options);

    # Determine if there were additional parameters that were not options. If
    # so, these should be files
    if (@ARGV) {
	set_files(@ARGV);
    }

    # Add those parameters that are dependent on the provided values
    _add_extra_parameters($self);

    _guess_missing_values($self);

    return $self;
}

sub set_files {
    my @files=@_;

    # Check if we can guess from the files what they are
    if (@files == 1) {
	# These are single
	my $file=shift @files;
	print STDERR "Assuming single end reads for $file\n";
    } elsif (@files == 2) {
	# These are likely to be paired
	print STDERR "Assuming paired end reads for:\n";
	print STDERR join("\t",@files),"\n";
    } else {
	die "Unable to decide if input read files are paired or not\n";
    }
}

sub set_commondb {
    my $self=shift;
    my $value=shift;

    my $dbh=MySQL_DB_Connect($value);
    $self->{'commondbh'}=$dbh;
    $self->{'commondb'}=$value;

    print STDERR "Here";

    return($self);
}

sub set_database {
    my $self=shift;
    my $value=shift;

    my $dbh=MySQL_DB_Connect($value);
    $self->{'dbh'}=$dbh;
    $self->{'database'}=$value;

    print STDERR "Here";

    return($self);
}

sub _add_extra_parameters {
    my $self=shift;

    $self->{'proj_prefix'}=join('_',
				$self->{'project'},
				$self->{'experiment'});
    return($self);
}

sub _guess_missing_values {
    my $self=shift;

    my $dbh=$self->get_commondbh();

    foreach my  $opt (keys %{$self}) {
	if (defined $self->{$opt}) {
	    print STDERR $opt,"\tDefined as ",$self->{$opt},"\n";
	} else {
	    print STDERR $opt,"\tUndefined\n";
	    my $subname='guess_'.$opt;
	    $self->$subname($opt);
	    print STDERR "Setting to:",$self->{$opt},"\n";
	}
    }

    return($self);
}

sub print_options {
    my $self=shift;
    my $missing=shift;

    foreach my $opt (sort keys %{$self}) {
	if ($missing && $self->{$opt}) {next;} 
	my $val=$self->{$opt} || '-';
	print join("\t",
		   uc($opt),
		   $val),"\n";
    }
}

sub _initialize {
    my $self=shift;
    my $options=shift;

    # Set each of the defined options
    foreach my $option (keys %{$options}) {
	my $subname='set_'.$option;
	$self->$subname($options->{$option});
	print STDERR join("\t",
			  $subname,
			  $option,
			  $options->{$option}),"\n";
    }
    <STDIN>;

    $self->{'species'} = undef unless $self->{'species'};
    $self->set_project(undef) unless $self->get_project();
    $self->set_experiment(undef) unless $self->get_experiment();
    $self->{'template'} = 'template.txt' unless $self->{'template'};
    $self->{'annotation'} = undef unless $self->{'annotation'};
    $self->{'genome'} = undef unless $self->{'genome'};
    $self->{'files'} = 'read.list.txt' unless $self->{'files'};
    $self->{'host'} = 'localhost' unless $self->{'host'};
    $self->set_commondb('TestRNAseqPipelineCommon') unless $self->get_commondb();
    $self->set_database('TestRNAseqPipeline') unless $self->get_database();
    $self->{'mismatches'} = 2 unless $self->{'mismatches'};
    $self->{'stranded'} = 0 unless $self->{'stranded'};
    $self->{'readlength'} = undef unless $self->{'readlength'};
    $self->{'mapper'} = 'GEM' unless $self->{'mapper'};
    $self->{'threads'} = 2 unless $self->{'threads'};
    $self->{'localdir'} = undef unless $self->{'localdir'};
    $self->{'cluster'} = '-' unless $self->{'cluster'};
    $self->{'qualities'} = 'ignore' unless $self->{'qualities'};
    $self->{'preprocess'} = '' unless $self->{'preprocess'};
    $self->{'preprocess_trim_length'} = 0 unless $self->{'preprocess_trim_length'};
    $self->{'input'} = 'fastqc' unless $self->{'input'};

    return $self;
}

sub guess_localdir {
    my $self=shift;

    my $project_dir=getcwd();
    chomp($project_dir);
    $self->{'localdir'}=$project_dir."/work";

    return($self);
}

# This should set the experiment value and also insert it in the necessary
# tables
sub set_experiment {
    my $self=shift;
    my $value=shift || die "No experiment ID has been provided\n";

    if ($value=~/([^\w_])/o) {
	my $char=$1;
	warn "WARNING: Experiment value $value contains an invalid character: '$char'\n";
    }

    $self->{'experiment'} = $value;

    return($self);
}

# This should set the project value and also insert it in the correct tables
sub set_project {
    my $self=shift;
    my $value=shift || die "No project ID has been provided\n";

    if ($value=~/([^\w_])/o) {
	my $char=$1;
	warn "WARNING: Project value $value contains an invalid character: '$char'\n";
    }

    $self->{'project'} = $value;

    return($self);
}

sub set_qualities {
    my $self=shift;
    my $value=shift;

    unless ($value=~/(solexa|phred|ignore)$/o) {
	my $char=$1;
	warn "WARNING: Qualities value $value contains an invalid character: '$char'\n";
    }

    return $self->{'qualities'} = $value;
}

sub set_preprocess_trim_length {
    my $self=shift;
    my $value=shift;

    unless ($value=~/^(<?=?(\d)+)$/o) {
	my $char=$1;
	warn "WARNING: Qualities value $value contains an invalid character: '$char'\n";
    }
    
    $self->{'preprocess_trim_length'} = $value;

    return($self);
}

# Set the information dependent on the species
sub set_species_table {
    my $self=shift;
    my $species=shift;

    # Annotation tables: Depend only on annotation
    my $table='species_info';
    my $type='species';
    my $field='species_id';
    my $dbh=$self->get_commondbh() || die "Unknown dbh\n";

    my ($query,$sth,$species_id);

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$species],
			   $table,
			   $field);
    
    my $count=$sth->execute($species);
    if ($count == 1) {
	# The entry is present
	($species_id)=$sth->execute($species);
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $species is present more than once in $table\n";
    } else {
	# The entry is absent and we must set it
	# Get the genus and abbreviation
	my ($genus,$specific)=split(/\s+/,$species,2);
	my $abbreviation=join('',
			      substr($genus,0,1),
			      substr($specific,0,3));
	
	# Insert the info into the database
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET species = ? , genus = ? , abbreviation = ?, sp_alias = ? ';
	print STDERR "Executing: $query\n";
	my $sth2=$dbh->prepare($query);
	$sth2->execute($species,$genus,$abbreviation,'-');
    }
    # Get the Id of the value we just inserted
    $sth->execute($species);
    ($species_id)=$sth->fetchrow_array();

    $self->{'species_id'} = $species_id;
    $self->{'species'} = $species;
}

# Set the information dependent on the annotation
sub set_annotation2 {
    my $self=shift;
    my $file=shift;

    my $species_id=$self->get_species_id();
    my $species=$self->get_species();

    my $value=$file;
    $value=~s/^.*\///;

    unless (-r $file) {
	warn "WARNING: Annotation file supplied is not readable: $!\n";
    }
    
    # Annotation tables: Depend only on annotation
    my $table='annotation_tables';
    my $type='annotation';
    my $field='annotation_id';
    my $dbh=$self->get_commondbh();
    my ($query,$sth,$annotation_id);
    $query ='SELECT table_name ';
    $query.="FROM $table ";
    $query.='WHERE annotation_id = ? AND type = ?';
    $sth=$dbh->prepare($query);

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$value],
			   $table,
			   $field);
    
    my $count=$sth->execute($value);
    if ($count == 1) {
	# The entry is present
	($annotation_id)=$sth->fetchrow_array();
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $value is present more than once in $table\n";
    } else {
	# first we will check the file to see if it conforms to the gff
	# format
	my $fileok=check_gff_file($value);
	my ($version,$source)=('\N','\N');
	
	# The entry is absent and we must set it
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET annotation= ? , species_id= ? , location= ? ';
	my $sth2=$dbh->prepare($query);
	$sth2->execute($value,$species,$file);
    }
    # Get the Id of the value we just inserted
    $sth->execute($value);
    my ($field_id)=$sth->fetchrow_array();

    $self->{'annotation_id'} = $field_id;
    $self->{'annotation'} = $file;

    # Now set the Annotation tables: These also depend only on annotation
    my ($query3,$sth3);
    $query3 ='SELECT table_name ';
#    $query3.="FROM $table3 ";
    $query3.='WHERE annotation_id = ? AND type = ?';
    $sth3=$dbh->prepare($query3);

   # Set or get the information on the naming of the annotation tables that
    # correspond to the genome and annotation we are looking at.
    # Get the common sth for this table
    my ($ins_query3,$ins_sth3);
 #   $ins_query3 ="INSERT INTO $table3 ";
    $ins_query3.='SET genome_id = ?,annotation_id = ?,';
    $ins_query3.='type = ?,table_name = ?';
    $ins_sth3=$dbh->prepare($ins_query3);
}

sub set_genome {
    my $self=shift;
    my $file=shift;

    unless (-r $file) {
	warn "WARNING: Genome file supplied is not readable: $!\n";
    }
    
    return $self->{'genome'} = $file;
}

sub _set_file_table {
    my $dbh=shift;
    my $table=shift;
    my ($query,$sth);
    $query ='SELECT location ';
    $query.="FROM $table ";
    $query.='WHERE genome_id = ? AND annotation_id = ? AND type = ?';
    $sth=$dbh->prepare($query);
}

#sub set_genomeindex {
#    my $self=shift;
#    my $filetype=shift;
#    my $present=0;

#    my $table='indices';
#    my $project_dir=$self->get_projectdir();
#    my $fasta_name=$self->get_genome();
#    $fasta_name=~s/\.fa$//;
#    my $location=$project_dir.'/GEMIndices/'.$fasta_name;
    
#    my $count=$sth->execute($genome_id,0,'genome');
#    if ($count > 0) {
#	if ($count == 1) {
#	    ($location)=$sth1->fetchrow_array();
#	    $present=1;
#	} else {
#	    warn "More than one entry retrieved for $genome\n";
#	    $present=1
#	}
#    }
#    if ($present) {
#	print $log_fh "File present at $location\n";
#    } else {
#	print $log_fh "File not present. Will be built at $location\n";
#	# The entry is absent and we must set it
#	print $log_fh "Executing: $ins_query1 for $location\n";
#	$ins_sth1->execute($genome_id,0,$species_id,
#			   $filetype,$location);
#    }
#    return($location);
#};



sub AUTOLOAD {
    my $self = shift;
    return if ($AUTOLOAD =~ /DESTROY/); # don't mess with garbage collection

    if (($AUTOLOAD =~ /.*set_(\w+)/) and (@_)) {
	my $key=$1;
	my $value=shift;
	if ($value=~/([^\w_\/\. -])/o) {
	    my $char=$1;
	    warn "WARNING: Value $value corresponding to $key contains an invalid character: '$char'\n";
	}
	return $self->{$key} = $value;
    } elsif ($AUTOLOAD =~ /.*get_(\w+)/) {
	my $key=$1;
        return $self->{$key};
    } else {
	die "Bad method call $AUTOLOAD\n";
    }
}


1;

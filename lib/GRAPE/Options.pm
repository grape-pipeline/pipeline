package GRAPE::Options;

use strict;
use warnings;
use Getopt::Long;
use Cwd;


use vars qw($AUTOLOAD);
use GRAPE::DBinterface ('MySQL_DB_Connect',
			'check_field_value','check_table_existence',
			'create_MySQL_table');

use GRAPE::Formats::Fasta ('check_fasta_file');
use GRAPE::Formats::GFF ('check_gff_file');

##################################################
## This should manage the options generated by the start script
##################################################
sub new {
    my $class =shift;
    my $tables=shift;
    
    my $self  = {};
    bless($self,$class);
    
    my %options;
    my $success=GetOptions(\%options,
			   'species|s=s',
			   'project=s',
			   'experiment=s',
			   'clean',
			   'help|h',
			   'man',
			   'debug|d+',
			   'template|t=s',
			   'annotation|a=s',
			   'genome|g=s',
			   'files=s',
			   'host=s',
			   'commondb=s',
			   'database=s',
			   'geneclass=s',
			   'transclass=s',
			   'junctionstable=s',
			   'junctionsclass=s',
			   'exonsclass=s',
			   'mismatches=i',
			   'paired',
			   'stranded',
			   'readlength=i',
			   'mapper=s',
			   'threads=i',
			   'genomeindex=s',
			   'transcriptomeindex=s',
			   'junctionsindex=s',
			   'exclusionfile=s',
			   'localdir=s',
			   'cluster=s',
			   'qualities=s',
			   'cellline=s',
			   'compartment=s',
			   'run_description=s',
			   'projdesc=s',
			   'secret=s',
			   'rnafrac=s',
			   'bioreplicate=s',
			   'preprocess=s',
			   'preprocess_trim_length=s',
			   'fluxmem=i',
			   'genomeassembly=s',
			   'genomesource=s',
			   'gender=s',
			   'annotationversion=s',
			   'annotationsource=s',
			   'protocolinfo=s',
			   'protocolshort=s'
	);

    # Determine if the options were all read correctly
    $self->set_help(1) unless $success;
    return($self) unless $success;

    # Initialize the options that need to be present with the provided values or
    # reasonable defaults if they are missing
    $self->_initialize(\%options);

    # Determine if there were additional parameters that were not options. If
    # so, these should be files
    if (@ARGV) {
	$self->set_files(@ARGV);
    }

    # Add those parameters that are dependent on the provided values
    if ($tables) {
	_add_extra_parameters($self,
			      $tables);
    }

    return $self;
}

sub set_files {
    my $self=shift;
    my @files=@_;

    # Check if we can guess from the files what they are
    if (@files == 1) {
	# These are single
	my $file=shift @files;
	print STDERR "Assuming single end reads for $file\n";
    } elsif (@files == 2) {
	# These are likely to be paired
	print STDERR "Assuming paired end reads for:\n";
	print STDERR join("\t",@files),"\n";
	$self->{'paired'}=1;
    } else {
	die "Unable to decide if input read files are paired or not\n";
    }

    $self->set_filelist(\@files);
    
    return($self)
}

sub set_commondb {
    my $self=shift;
    my $value=shift;

    my $dbh=MySQL_DB_Connect($value);
    $self->{'commondbh'}=$dbh;
    $self->{'commondb'}=$value;

    return($self);
}

sub set_database {
    my $self=shift;
    my $value=shift;

    my $dbh=MySQL_DB_Connect($value);
    $self->{'dbh'}=$dbh;
    $self->{'database'}=$value;

    return($self);
}

sub set_species {
    my $self=shift;
    my $value=shift || die "No species has been provided\n";

    my @species=split(/\s+/,$value);
    if (@species < 2) {
	die "WARNING: Species name ($value) does not look right. Should have a Genus and species name at least\n";
    }

    if ($value=~/([^\w_\/\. -])/o) {
	my $char=$1;
	warn "WARNING: Species value $value contains an invalid character: '$char'\n";
    }

    $self->{'species'} = $value;

    return($self);
}

sub _add_extra_parameters {
    my $self=shift;
    my $tables=shift;

    $self->{'proj_prefix'}=join('_',
				$self->{'project'},
				$self->{'experiment'});
    $self->{'CommonTables'}=$tables;

    # Set the prefix
    $self->set_prefix();

    # If the clean option is set skip alll the pable creation steps
    if ($self->get_clean()) {
	return($self);
    }

    # Set the species tables
    $self->set_species_tables();

    # Set the genome tables, which depend on the species tables
    $self->set_genome_tables();

    # Set the annotation tables, which depend on species and genome
    $self->set_annotation_tables();

    # Set the exclusion files table
    $self->set_exclusion_tables();

    # Set the fasta files table
    $self->set_fasta_files_tables();

    # Set the indices table
    $self->set_indices_tables();

    # Set the protocol info table
    $self->set_protocol_info();

    # Set the projects table
    $self->add_project();

    # set the experiments table
    $self->add_experiment();

    return($self);
}

sub set_prefix {
    my $self=shift;
    my $project=$self->get_project();
    my $experiment=$self->get_experiment();
    
    $self->{'prefix'}=join('_',
			   $project,
			   $experiment);
}

sub print_options {
    my $self=shift;
    my $missing=shift;

    foreach my $opt (sort keys %{$self}) {
	if ($missing && $self->{$opt}) {next;} 
	my $val=$self->{$opt} || '-';
	print join("\t",
		   uc($opt),
		   $val),"\n";
    }
}

sub _initialize {
    my $self=shift;
    my $options=shift;

    # Set each of the defined options
    foreach my $option (keys %{$options}) {
	my $subname='set_'.$option;
	$self->$subname($options->{$option});
    }

    # Add the defaults for those cases that have not been defined
    $self->set_species(undef) unless $self->get_species();
    $self->set_project('QuickRun') unless $self->get_project();
    $self->set_experiment('QuickRun') unless $self->get_experiment();
    $self->set_template('template.txt') unless $self->get_template();
    $self->set_annotation(undef) unless $self->get_annotation();
    $self->set_genome(undef) unless $self->get_genome();
    $self->{'files'} = 'read.list.txt' unless $self->{'files'};
    $self->{'host'} = 'localhost' unless $self->{'host'};
    $self->set_commondb('test') unless $self->get_commondb();
    $self->set_database('test') unless $self->get_database();
    $self->{'mismatches'} = 2 unless $self->{'mismatches'};
    $self->{'stranded'} = 0 unless $self->{'stranded'};
    $self->{'paired'} = 0 unless $self->{'paired'};
    $self->{'readlength'} = undef unless $self->{'readlength'};
    $self->{'mapper'} = 'GEM' unless $self->{'mapper'};
    $self->{'threads'} = 2 unless $self->{'threads'};
    $self->guess_localdir() unless $self->get_localdir();
    $self->{'cluster'} = '-' unless $self->{'cluster'};
    $self->{'qualities'} = 'ignore' unless $self->{'qualities'};
    $self->{'preprocess'} = 'zcat' unless $self->{'preprocess'};
    $self->{'preprocess_trim_length'} = 0 unless $self->{'preprocess_trim_length'};
    $self->{'input'} = 'fastqc' unless $self->{'input'};
    $self->set_projectdir() unless $self->get_projectdir();
    $self->set_indexdir() unless $self->get_indexdir();
    $self->set_fluxmem('16G') unless $self->get_fluxmem();
    $self->set_protocolinfo('none') unless $self->get_protocolinfo();
    $self->set_protocolshort('-') unless $self->get_protocolshort();
    $self->set_projdesc('-') unless $self->get_projdesc();

    return $self;
}

sub set_projectdir {
    my $self=shift;

    my $project_dir=getcwd();
    chomp($project_dir);
    $self->{'projectdir'}=$project_dir;

    return($self);
}

sub set_indexdir {
    my $self=shift;

    my $project_dir=$self->get_projectdir();
    $self->{'indexdir'}=$project_dir."/GEMIndices";

    return($self);
}

sub guess_localdir {
    my $self=shift;

    my $project_dir=getcwd();
    chomp($project_dir);
    $self->set_localdir($project_dir."/work");

    return($self);
}

sub set_template {
    my $self=shift;
    my $file=shift;

    unless ($file && -r $file) {
	die "Template file supplied is not readable: $!\n";
    }
    
    return $self->{'template'} = $file;
}

# This should set the experiment value and also insert it in the necessary
# tables
sub set_experiment {
    my $self=shift;
    my $value=shift || die "No experiment ID has been provided\n";

    if ($value=~/([^\w_])/o) {
	my $char=$1;
	warn "WARNING: Experiment value $value contains an invalid character: '$char'\n";
    }
    if (length($value) > 13) {
	die "WARNING: Value $value corresponding to experiment is too long. Please limit it to 12 characters\n";
    }

    $self->{'experiment'} = $value;

    return($self);
}

# This should set the project value and also insert it in the correct tables
sub set_project {
    my $self=shift;
    my $value=shift || die "No project ID has been provided\n";

    if ($value=~/([^\w_])/o) {
	my $char=$1;
	warn "WARNING: Project value $value contains an invalid character: '$char'\n";
    }
    if (length($value) > 13) {
	die "WARNING: Value $value corresponding to project is too long. Please limit it to 12 characters\n";
    }

    $self->{'project'} = $value;

    return($self);
}

sub set_qualities {
    my $self=shift;
    my $value=shift;

    unless ($value=~/(solexa|phred|ignore)$/o) {
	my $char=$1;
	die "WARNING: Qualities value $value contains an invalid character: '$char'\n";
    }

    return $self->{'qualities'} = $value;
}

sub set_preprocess_trim_length {
    my $self=shift;
    my $value=shift;

    unless ($value=~/^(<?=?(\d)+)$/o) {
	my $char=$1;
	die "WARNING: Qualities value $value contains an invalid character: '$char'\n";
    }
    
    $self->{'preprocess_trim_length'} = $value;

    return($self);
}

sub set_genome {
    my $self=shift;
    my $file=shift;

    unless ($file && -r $file) {
	die "Genome file is not readable: $!\n";
    }
    
    return $self->{'genome'} = $file;
}

sub set_annotation {
    my $self=shift;
    my $file=shift;

    unless ($file && -r $file) {
	die "Annotation file is not readable: $!\n";
    }
    
    return $self->{'annotation'} = $file;
}

# Set the information dependent on the species
sub set_species_tables {
    my $self=shift;
    my $species=$self->get_species();

    # Annotation tables: Depend only on species
    my $table='species_info';
    my $type='species';
    my $field='species_id';
    my $dbh=$self->get_commondbh() || die "Unknown dbh\n";

    my ($query,$sth,$species_id);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);
    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$species],
			   $table,
			   $field);
    
    my $count=$sth->execute($species);
    if ($count == 1) {
	# The entry is present
	($species_id)=$sth->execute($species);
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $species is present more than once in $table\n";
    } else {
	# The entry is absent and we must set it
	# Get the genus and abbreviation
	my ($genus,$specific)=split(/\s+/,$species,2);
	my $abbreviation=join('',
			      substr($genus,0,1),
			      substr($specific,0,3));
	
	# Insert the info into the database
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET species = ? , genus = ? , abbreviation = ?, sp_alias = ? ';
	print STDERR "Executing: $query\n";
	my $sth2=$dbh->prepare($query);
	$sth2->execute($species,$genus,$abbreviation,'-');
    }
    # Get the Id of the value we just inserted
    $sth->execute($species);
    ($species_id)=$sth->fetchrow_array();

    $self->{'species_id'} = $species_id;
}

sub set_genome_tables {
    my $self=shift;
    my $location=$self->get_genome();
    my $genome=$location;
    $genome=~s/.*\///;

    my $species_id=$self->get_species_id();
    my $species=$self->get_species();

    # Genome tables: Depend only on genome and species
    my $table='genome_files';
    my $type='genome';
    my $field='genome_id';
    my $dbh=$self->get_commondbh() || die "Unknown dbh\n";
    my ($query,$sth,$genome_id);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);
    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$genome],
			   $table,
			   $field);
    
    my $count=$sth->execute($genome);
    if ($count == 1) {
	# The entry is present
	($genome_id)=$sth->execute($genome);
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $genome is present more than once in $table\n";
    } else {
	unless (-r $location) {
	    warn "WARNING: Genome file supplied is not readable: $!\n";
	}
    
	# First check if the fasta files is ok
	my $fileok=check_fasta_file($location);
	unless ($fileok) {
	    die "There is a problem with the genome file, so I'm quitting. Please check it\n";
	}

	# Fill in some possible extra arguments
	my $genomeassembly=$self->get_genomeassembly() || '\N';
	my $genomesource=$self->get_genomesource() || '\N';
	my $gender=$self->get_gender() || '\N';
    
	# The entry is absent and we must set it
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET genome= ? , species_id= ? , location= ? ,';
	$query.='assembly= ? , source= ? , gender= ? ';
	print STDERR "Executing: $query\n";
	my $sth2=$dbh->prepare($query);
	$sth2->execute($genome,$species,$location,
		       $genomeassembly,$genomesource,$gender);
    }

    # Get the Id of the value we just inserted
    $sth->execute($genome);
    ($genome_id)=$sth->fetchrow_array();

    $self->{'genome_id'} = $genome_id;
}

# Set the information dependent on the annotation
sub set_annotation_tables {
    my $self=shift;
    my $location=$self->get_annotation();
    my $annotation=$location;
    $annotation=~s/^.*\///;

    my $species_id=$self->get_species_id();
    my $species=$self->get_species();
    my $genome_id=$self->get_genome_id();

    # Annotation tables: Depend on species genome and annotation
    my $table='annotation_files';
    my $type='annotation';
    my $field='annotation_id';
    my $dbh=$self->get_commondbh() || die "Unknown dbh\n";
    my ($query,$sth,$annotation_id);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$annotation],
			   $table,
			   $field);
    
    my $count=$sth->execute($annotation);
    if ($count == 1) {
	# The entry is present
	($annotation_id)=$sth->fetchrow_array();
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $annotation is present more than once in $table\n";
    } else {
	unless (-r $location) {
	    warn "WARNING: Annotation file supplied is not readable: $!\n";
	}
	# First check the file to see if it conforms to the UCSC gff format
	my $fileok=check_gff_file($location);
	unless ($fileok) {
	    die "There is a problem with the genome file, so I'm quitting. Please check it\n";
	}

	# Fill in some possible extra arguments
	my $annotationversion=$self->get_annotationversion() || '\N';
	my $annotationsource=$self->get_annotationsource() || '\N';
	
	# The entry is absent and we must set it
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET annotation= ? , species_id= ? , location= ? ,';
	$query.='version= ? , source= ? ';
	my $sth2=$dbh->prepare($query);
	$sth2->execute($annotation,$species,$location,
		       $annotationversion,$annotationsource);
    }
    # Get the Id of the value we just inserted
    $sth->execute($annotation);
    ($annotation_id)=$sth->fetchrow_array();

    $self->{'annotation_id'} = $annotation_id;

    # Now build the annotation table: It depends only on annotation and genome
    _fill_annotation_table($self,
			   'exonsclass');
    _fill_annotation_table($self,
			   'transclass');
    _fill_annotation_table($self,
			   'geneclass');
    _fill_annotation_table($self,
			   'junctionsclass');
    _fill_annotation_table($self,
			   'junctionstable');
}

sub _fill_annotation_table {
    my $self=shift;
    my $type=shift;

    my $table='annotation_tables';
    my $annotation_id=$self->get_annotation_id();
    my $genome_id=$self->get_genome_id();
    my $dbh=$self->get_commondbh();
    my $annotation=$self->get_annotation();

    my %suffix=('junctionsclass' => 'junctclass',
		'exonsclass' => 'exclass',
		'junctionstable' => 'junct');

    # Check if the table exists and create it if it does not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    my ($query,$sth,$count,$table_name);
    $query ='SELECT table_name ';
    $query.="FROM $table ";
    $query.='WHERE annotation_id = ? AND type = ?';
    $sth=$dbh->prepare($query);

    # Set or get the information on the naming of the annotation tables that
    # correspond to the genome and annotation we are looking at.
    # Get the common sth for this table    
    $count=$sth->execute($annotation_id,$type);
    if ($count > 0) {
	if ($count == 1) {
	    ($table_name)=$sth->fetchrow_array();
	} else {
	    die "More than one $table entry retrieved for $annotation\n";
	}
    } else {
	# get the required information from the annotation
	my $annot_string=$annotation;
	$annot_string=~s/.*\///;
	$annot_string=substr($annot_string,0,30);
	$table_name=$annotation_id.'_'.$annot_string;
	$table_name.='_'.($suffix{$type} || $type);
	$table_name=~s/\./_/g;
	print STDERR "Table entry not present. Will be built in $table_name\n";

	# The table is not present so we will fil into the database the 
	# location where it will be built
	my ($ins_query,$ins_sth);
	$ins_query ="INSERT INTO $table ";
	$ins_query.='SET genome_id = ?,annotation_id = ?,';
	$ins_query.='type = ?,table_name = ?';
	$ins_sth=$dbh->prepare($ins_query);

	# The entry is absent and we must set it
	print STDERR "Executing: $ins_query\n";
	$ins_sth->execute($genome_id,$annotation_id,
			  $type,$table_name);
    }
    $self->{$type}=$table_name;
}

sub set_exclusion_tables {
    my $self=shift;
    my $annotation_id=$self->get_annotation_id();
    my $species_id=$self->get_species_id();
    my $annotation=$self->get_annotation();
    my $dbh=$self->get_commondbh();
    my $project_dir=$self->get_projectdir();
    my $table='exclusion_files';
    my ($query,$sth,$exclusion_id,$exclusionfile);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Exclusion query: depends only on annotation
    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   ['annotation_id',$annotation_id],
			   $table,
			   'location');

    # Get the exclusion file if present or set the location to build it if
    # absent
    my $count=$sth->execute($annotation_id);
    if ($count > 0) {
	if ($count == 1) {
	    ($exclusionfile)=$sth->fetchrow_array();
	} else {
	    warn "More than one $table entry retrieved for $annotation\n";
	}
    } else {
	# The entry is absent and we must set it
	$exclusionfile=$annotation;
	$exclusionfile=~s/.*\///;
	$exclusionfile=~s/\.g[tf]f//;
	$exclusionfile.='.exclusion';
	$exclusionfile=$project_dir.'/GEMIndices/'.$exclusionfile;
    
	print STDERR "File not present. Will be built at $exclusionfile\n";

	my ($ins_query,$ins_sth);
	$ins_query ="INSERT INTO $table ";
	$ins_query.='SET annotation_id = ?,species_id = ?,location = ?';
	print STDERR "Executing: $ins_query\n";
	$ins_sth=$dbh->prepare($ins_query);
	$ins_sth->execute($annotation_id,$species_id,$exclusionfile);
	$ins_sth->finish();
    }

    # Set the entry we just inserted
    $self->{'exclusionfile'} = $exclusionfile;
}

sub set_fasta_files_tables {
    my $self=shift;

    my $dbh=$self->get_commondbh();
    my $table='fasta_files';

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Now build the fasta files table: It depends only on annotation and genome
    _fill_fasta_table($self,
		      'exonsfasta');
    _fill_fasta_table($self,
		      'junctionsfasta');
    _fill_fasta_table($self,
		      'transcriptomefasta');
}

sub _fill_fasta_table {
    my $self=shift;
    my $type=shift;

    my $table='fasta_files';
    my $annotation_id=$self->get_annotation_id();
    my $genome_id=$self->get_genome_id();
    my $annotation=$self->get_annotation();
    my $genome=$self->get_genome();
    my $dbh=$self->get_commondbh();
    my $indexdir=$self->get_indexdir();

    my %suffix=('exonsfasta' => 'exons.fa',
		'junctionsfasta' => 'junctions.fa',
		'transcriptomefasta' => 'transcripts.fa');

    # Check if the table exists and die it if it does not, as ift should
    # have been created in sub that calls this one
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	die "$table is absent\n";
    }

    my ($query,$sth,$count,$fasta_name);
    $query ='SELECT file_name ';
    $query.="FROM $table ";
    $query.='WHERE annotation_id = ? AND genome_id = ? AND filetype = ?';
    $sth=$dbh->prepare($query);

    # Set or get the information on the naming of the annotation tables that
    # correspond to the genome and annotation we are looking at.
    # Get the common sth for this table    
    $count=$sth->execute($annotation_id,$genome_id,$type);
    if ($count > 0) {
	if ($count == 1) {
	    ($fasta_name)=$sth->fetchrow_array();
	} else {
	    die "More than one $table entry retrieved for $genome_id and $annotation_id\n";
	}
    } else {
	# Get the required information from the annotation and genome
	$genome=~s/.*\///;
	$annotation=~s/.*\///;
	my $fasta_name=$annotation.'.'.$genome;
	$fasta_name=~s/\.g[tf]f//g;
	$fasta_name=~s/\.fa(stq)?$//;
	$fasta_name.='.'.($suffix{$type} || $type);
	$fasta_name=$indexdir.'/'.$fasta_name;
	print STDERR "$type entry not present. Will be built in $fasta_name\n";

	# The entry is not present so we will fil into the database the 
	# location where the file will be built
	my ($ins_query,$ins_sth);
	$ins_query ="INSERT INTO $table ";
	$ins_query.='SET genome_id = ?,annotation_id = ?,';
	$ins_query.='filetype = ?,file_name = ?';
	$ins_sth=$dbh->prepare($ins_query);

	# The entry is absent and we must set it
	print STDERR "Executing: $ins_query\n";
	$ins_sth->execute($genome_id,$annotation_id,
			  $type,$fasta_name);
    }
    $self->{$type}=$fasta_name;
}

sub set_indices_tables {
    my $self=shift;

    my $dbh=$self->get_commondbh();
    my $table='indices';

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Fill in the different indices
    _fill_indices_table($self,
			'genomeindex');
    _fill_indices_table($self,
			 'junctionsindex');
    _fill_indices_table($self,
			'transcriptomeindex');
}

sub _fill_indices_table {
    my $self=shift;
    my $type=shift;

    my $table='indices';
    my $annotation_id=$self->get_annotation_id();
    my $genome_id=$self->get_genome_id();
    my $annotation=$self->get_annotation();
    my $genome=$self->get_genome();
    my $dbh=$self->get_commondbh();
    my $indexdir=$self->get_indexdir();
    my $species_id=$self->get_species_id();

    my %suffix=('genomeindex' => 'genome',
		'transcriptomeindex' => 'transcriptome',
		'junctionsindex' => 'junctions');

    # Check if the table exists and die it if it does not, as it should
    # have been created in sub that calls this one
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	die "$table is absent\n";
    }

    # If the index is a genome index we don't need the annotation index
    if ($type eq 'genomeindex') {
	$annotation_id = 0;
    }

    my ($query,$sth,$count,$index);
    $query ='SELECT location ';
    $query.="FROM $table ";
    $query.='WHERE annotation_id = ? AND genome_id = ? AND type = ?';
    $sth=$dbh->prepare($query);

    # Set or get the information on the naming of the annotation tables that
    # correspond to the genome and annotation we are looking at.
    # Get the common sth for this table
    $count=$sth->execute($annotation_id,$genome_id,$type);
    if ($count > 0) {
	if ($count == 1) {
	    ($index)=$sth->fetchrow_array();
	} else {
	    die "More than one $table entry retrieved for $genome_id and $annotation_id\n";
	}
    } else {
	# Get the required information from the annotation and genome
	$genome=~s/.*\///;
	$annotation=~s/.*\///;
	if ($type eq 'genomeindex') {
	    $index=$genome;
	} else {
	    $index=$annotation.'.'.$genome;
	}
	
	$index=~s/\.g[tf]f//g;
	$index=~s/\.fa(stq)?$//;
	$index.='.'.($suffix{$type} || $type);
	$index=$indexdir.'/'.$index;
	print STDERR "$type entry not present. Will be built in $index\n";

	# The entry is not present so we will fill into the database the 
	# location where the file will be built
	my ($ins_query,$ins_sth);
	$ins_query ="INSERT INTO $table ";
	$ins_query.='SET genome_id = ?,annotation_id = ?, species_id = ?,';
	$ins_query.='type = ?,location = ?';
	$ins_sth=$dbh->prepare($ins_query);

	# The entry is absent and we must set it
	print STDERR "Executing: $ins_query\n";
	$ins_sth->execute($genome_id,$annotation_id,$species_id,
			  $type,$index);
    }
    $self->{$type}=$index;
}

# Build the protocol info table and fill it with any available protocol
# information
# Set the information dependent on the species
sub set_protocol_info {
    my $self=shift;
    my $protocol=$self->get_protocolinfo();
    my $short=$self->get_protocolshort();

    # Annotation tables: Depend only on species
    my $table='protocol_info';
    my $type='abbreviation';
    my $field='protocol_id';
    my $dbh=$self->get_commondbh() || die "Unknown dbh\n";

    my ($query,$sth,$protocol_id);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);
    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$short],
			   $table,
			   $field);
    
    my $count=$sth->execute($short);
    if ($count == 1) {
	# The entry is present
	($protocol_id)=$sth->execute($short);
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $short is present more than once in $table\n";
    } else {
	# The entry is absent and we must set it
	# Insert the info into the database
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET abbreviation = ? , description = ?';
	print STDERR "Executing: $query\n";
	my $sth2=$dbh->prepare($query);
	$sth2->execute($short,$protocol);
    }
    # Get the Id of the value we just inserted
    $sth->execute($short);
    ($protocol_id)=$sth->fetchrow_array();

    $self->{'protocol_id'} = $protocol_id;
}

# Add the project and experiment information to the database
sub add_project {
    my $self=shift;

    my $project=$self->get_project();
    my $species=$self->get_species();
    my $proj_desc=$self->get_projdesc();
    my $secret=$self->get_secret();
    my $dbh=$self->get_commondbh();

    print STDERR "Checking for the presence of $project in the database...\n";
    my $table='projects';
    my ($query,$sth,$count,$proj_id);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);
    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    $query ='SELECT project_id ';
    $query.="FROM $table ";
    $query.="WHERE project_id = ?";
    $sth=$dbh->prepare($query);
    $count=$sth->execute($project);

    my $update=0;
    if ($count == 1) {
	($proj_id)=$sth->fetchrow_array();
	print STDERR "$project is present in the database\n";
	print STDERR "Do you want to overwrite existing info? (y/N): ";
	my $yes=<STDIN>;
	chomp($yes);
	if ($yes=~/^y/i){
	    $update=1;
	    $query ="UPDATE $table ";
	    $query.='SET species = ? , project_id = ?, proj_description = ?,';
	    $query.='secret = ?';
	}
    } elsif ($count > 1) {
	die "Project ID is present many times. This should not happen\n";
    } else {
	print STDERR "$project is not present in the database\n";
	print STDERR "Adding a new entry\n";
	$update=1;
	$query ="INSERT INTO $table ";
	$query.='SET species = ? , project_id = ?, proj_description = ?,';
	$query.='secret = ?';
    }	

    if ($update) {
	# Insert the info into the database
	my $sth2=$dbh->prepare($query);
	$sth2->execute($species,$project,$proj_desc,$secret);
    }

    # Get the Id of the value we just inserted
    $sth->execute($project);
    ($proj_id)=$sth->fetchrow_array();

    $self->set_project_id($proj_id);
}

# Add the experiment information making sure the project id is present in the
# projects table
sub add_experiment {
    my $self=shift;

    my $project=$self->get_project();
    my $experiment=$self->get_experiment();
    my $species_id=$self->get_species_id();
    my $annotation_id=$self->get_annotation_id();
    my $genome_id=$self->get_genome_id();
    my $template=$self->get_template();
    my $read_length=$self->get_readlength();
    my $preprocess_trim_length=$self->get_preprocess_trim_length();
    my $mismatches=$self->get_mismatches();
    my $dbh=$self->get_commondbh();

    my $cellline=$self->get_cellline();
    my $compartment=$self->get_compartment();
    my $expdescription=$self->get_run_description();
    my $rnafrac=$self->get_rnafrac();
    my $bioreplicate=$self->get_bioreplicate();

    # If the preprocess trim length is constant set the new read length
    if ($preprocess_trim_length=~/^=?(\d)+$/o) {
	my $trim=$preprocess_trim_length;
	$trim=~s/^=//;
	print STDERR "Adjusting read length by $trim\n";
	print STDERR "$preprocess_trim_length\n";
	$read_length -= $trim;
	$expdescription.=" Original reads were trimmed by $preprocess_trim_length nucleotides";
    }

    # Check if the table is present and create it if not
    my $table='experiments';
    my $present=check_table_existence($dbh,
				      $table);
    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Check if the experiment is already present in the database
    print STDERR "Checking for the presence of $experiment in the database...\n";

    my ($query,$sth,$count);

    $query ='SELECT experiment_id ';
    $query.="FROM $table ";
    $query.='WHERE experiment_id = ? AND project_id = ?';
    $sth=$dbh->prepare($query);
    $count=$sth->execute($experiment,$project);

    my $update=0;
    if ($count == 1) {
	print STDERR "$experiment is already present as part of $project. Are you sure you want to overrite the previous information?(y/N): ";
	my $yes=<STDIN>;
	chomp($yes);
	if ($yes=~/^y/i){
	    $update=1;
	    print STDERR "Updating entry\n";
	    $query ="UPDATE $table ";
	    $query.='SET species_id = ?,';
	    $query.='genome_id = ?, annotation_id = ?, template_file = ?,';
	    $query.='read_length = ?, mismatches = ?, ';
	    $query.='CellType = ?, Compartment = ?, exp_description = ?,';
	    $query.='RNAType = ?, Bioreplicate = ? ';
	    $query.='WHERE experiment_id = ? AND project_id = ?';
	}
    } elsif ($count > 1) {
	die "Project ID with experiment ID combination is present many times. This should not happen\n";
    } else {
	print STDERR "$experiment is not present in the database for $project\n";
	print STDERR "Adding a new entry\n";
	$update=1;
	$query ="INSERT INTO $table ";
	$query.='SET species_id = ?,';
	$query.='genome_id = ?, annotation_id = ?, template_file = ?,';
	$query.='read_length = ?, mismatches = ?,';
	$query.='CellType = ?, Compartment = ?, exp_description = ?,';
	$query.='RNAType = ?, Bioreplicate = ?,';
	$query.='experiment_id = ?, project_id = ?';
    }

    if ($update) {
	# Insert the info into the database
	$sth=$dbh->prepare($query);
	$sth->execute($species_id,
		      $genome_id,$annotation_id,$template,
		      $read_length,$mismatches,
		      $cellline, $compartment, $expdescription,
		      $rnafrac,$bioreplicate,
		      $experiment,$project);
    }
}

sub AUTOLOAD {
    my $self = shift;
    return if ($AUTOLOAD =~ /DESTROY/); # don't mess with garbage collection

    if (($AUTOLOAD =~ /.*set_(\w+)/) and (@_)) {
	my $key=$1;
	my $value=shift;
	if ($value=~/([^\w_\/\. -])/o) {
	    my $char=$1;
	    warn "WARNING: Value $value corresponding to $key contains an invalid character: '$char'\n";
	}
	return $self->{$key} = $value;
    } elsif ($AUTOLOAD =~ /.*get_(\w+)/) {
	my $key=$1;
        return $self->{$key};
    } else {
	die "Bad method call $AUTOLOAD:$!\n";
    }
}


1;

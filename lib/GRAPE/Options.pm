package GRAPE::Options;

use strict;
use warnings;
use Getopt::Long;
use Cwd;


use vars qw($AUTOLOAD);
use GRAPE::DBinterface qw(MySQL_DB_Connect);

##################################################
## This should manage the options generated by the start script
##################################################
sub new {
    my $class =shift;
    
    my $self  = {};
    bless($self,$class);
    
    $self->_initialize();
    my %options;
    my $success=GetOptions(\%options,
			   'species|s=s',
			   'project=s',
			   'experiment=s',
			   'clean',
			   'help|h',
			   'man',
			   'debug|d+',
			   'template|t=s',
			   'annotation|a=s',
			   'genome|g=s',
			   'files=s',
			   'host=s',
			   'commondb=s',
			   'database=s',
#			   'geneclass=s',
			   'transclass=s',
			   'junctionstable=s',
			   'junctionsclass=s',
			   'exonsclass=s',
			   'mismatches=i',
			   'paired',
			   'stranded',
			   'readlength=i',
			   'mapper=s',
			   'threads=i',
			   'genomeindex=s',
			   'transcriptomeindex=s',
			   'junctionsindex=s',
			   'exclusionfile=s',
			   'localdir=s',
			   'cluster=s',
			   'qualities=s',
			   'cellline=s',
			   'compartment=s',
			   'run_description=s',
			   'projdesc=s',
			   'rnafrac=s',
			   'bioreplicate=s',
			   'preprocess=s',
			   'preprocess_trim_length=s'
	);

    # Set each of the defined options
    foreach my $option (keys %options) {
	my $subname='set_'.$option;
	$self->$subname($options{$option});
    }

    # Determine if the options were all read correctly
    $self->set_OptionsOK($success);

#    _guess_missing_values($self);

    return $self;
}

sub set_commondb {
    my $self=shift;
    my $value=shift;

    my $dbh=MySQL_DB_Connect($value);
    $self->{'commondbh'}=$dbh;

    return $self->{'commondb'}=$value
}

sub _guess_missing_values {
    my $self=shift;

    my $dbh=$self->get_commondbh();

    foreach my  $opt (keys %{$self}) {
	if (defined $self->{$opt}) {
	    print STDERR $opt,"\tDefined as ",$self->{$opt},"\n";
	} else {
	    print STDERR $opt,"\tUndefined\n";
	    my $subname='guess_'.$opt;
	    $self->$subname($opt);
	    print STDERR "Setting to:",$self->{$opt},"\n";
	}
    }

    return($self);
}

sub print_options {
    my $self=shift;

    foreach my $opt (keys %{$self->{'GRAPEOPTIONS'}}) {
	my $val=$self->{$opt} || '-';
	print join("\t",
		   uc($opt),
		   $val),"\n";
    }
}

sub _initialize {
    my $self=shift;

    $self->{'species'} = undef;
    $self->{'project'} = undef;
    $self->{'experiment'} = undef;
    $self->{'template'} = 'template.txt';
    $self->{'annotation'} = undef;
    $self->{'genome'} = undef;
    $self->{'files'} = 'read.list.txt';
    $self->{'host'} = 'localhost';
    $self->{'commondb'} = undef;
    $self->{'database'} = undef;
    $self->{'mismatches'} = 2;
    $self->{'stranded'} = 0;
    $self->{'readlength'} = undef;
    $self->{'mapper'} = 'GEM';
    $self->{'threads'} = 2;
    $self->{'localdir'} = undef;
    $self->{'cluster'} = '-';
    $self->{'qualities'} = 'ignore';
    $self->{'preprocess'} = '';
    $self->{'preprocess_trim_length'} = 0;

    return $self;
}

sub guess_localdir {
    my $self=shift;

    my $project_dir=getcwd();
    chomp($project_dir);
    $self->{'localdir'}=$project_dir."/work";

    return($self);
}

sub set_experiment {
    my $self=shift;
    my $value=shift || die "No experiment ID has been provided\n";

    if ($value=~/([^\w_])/o) {
	my $char=$1;
	warn "WARNING: Experiment value $value contains an invalid character: '$char'\n";
    }

    return $self->{'experiment'} = $value;
}

sub set_project {
    my $self=shift;
    my $value=shift || die "No project ID has been provided\n";

    if ($value=~/([^\w_])/o) {
	my $char=$1;
	warn "WARNING: Project value $value contains an invalid character: '$char'\n";
    }

    return $self->{'project'} = $value;
}

sub set_qualities {
    my $self=shift;
    my $value=shift;

    unless ($value=~/(solexa|phred|ignore)$/o) {
	my $char=$1;
	warn "WARNING: Qualities value $value contains an invalid character: '$char'\n";
    }

    return $self->{'qualities'} = $value;
}

sub set_preprocess_trim_length {
    my $self=shift;
    my $value=shift;

    unless ($value=~/^(<?=?(\d)+)$/o) {
	my $char=$1;
	warn "WARNING: Qualities value $value contains an invalid character: '$char'\n";
    }
    
    return $self->{'preprocess_trim_length'} = $value;
}

sub set_annotation {
    my $self=shift;
    my $file=shift;

    unless (-r $file) {
	warn "WARNING: Annotation file supplied is not readable: $!\n";
    }
    
    
    # Annotation tables: Depend only on annotation
    my $table='annotation_tables';
    my $dbh=$self->get_commondbh();    my ($query,$sth);
    $query ='SELECT table_name ';
    $query.="FROM $table ";
    $query.='WHERE annotation_id = ? AND type = ?';
    $sth=$dbh->prepare($query);

    # Set the junctionstable


    return $self->{'annotation'} = $file;
}

sub set_genome {
    my $self=shift;
    my $file=shift;

    unless (-r $file) {
	warn "WARNING: Genome file supplied is not readable: $!\n";
    }
    
    return $self->{'genome'} = $file;
}

sub _set_file_table {
    my $dbh=shift;
    my $table=shift;
    my ($query,$sth);
    $query ='SELECT location ';
    $query.="FROM $table ";
    $query.='WHERE genome_id = ? AND annotation_id = ? AND type = ?';
    $sth=$dbh->prepare($query);
}

sub set_genomeindex {
    my $self=shift;
    my $filetype=shift;
    my $present=0;

    my $table='indices';
    my $project_dir=$self->get_projectdir();
    my $fasta_name=$self->get_genome();
    $fasta_name=~s/\.fa$//;
    my $location=$project_dir.'/GEMIndices/'.$fasta_name;
    
    my $count=$sth->execute($genome_id,0,'genome');
    if ($count > 0) {
	if ($count == 1) {
	    ($location)=$sth1->fetchrow_array();
	    $present=1;
	} else {
	    warn "More than one entry retrieved for $genome\n";
	    $present=1
	}
    }
    if ($present) {
	print $log_fh "File present at $location\n";
    } else {
	print $log_fh "File not present. Will be built at $location\n";
	# The entry is absent and we must set it
	print $log_fh "Executing: $ins_query1 for $location\n";
	$ins_sth1->execute($genome_id,0,$species_id,
			   $filetype,$location);
    }
    return($location);
};



sub AUTOLOAD {
    my $self = shift;
    return if ($AUTOLOAD =~ /DESTROY/); # don't mess with garbage collection

    if (($AUTOLOAD =~ /.*set_(\w+)/) and (@_)) {
	my $key=$1;
	my $value=shift;
	if ($value=~/([^\w_\/\. -])/o) {
	    my $char=$1;
	    warn "WARNING: Value $value corresponding to $key contains an invalid character: '$char'\n";
	}
	return $self->{$key} = $value;
    } elsif ($AUTOLOAD =~ /.*get_(\w+)/) {
	my $key=$1;
        return $self->{$key};
    } else {
	die "Bad method call $AUTOLOAD\n";
    }
}


1;

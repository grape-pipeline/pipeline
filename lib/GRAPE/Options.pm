package GRAPE::Options;

use strict;
use warnings;
use Getopt::Long;
use Cwd;


use vars qw($AUTOLOAD);
use GRAPE::DBinterface ('MySQL_DB_Connect',
			'check_field_value','check_table_existence',
			'create_MySQL_table');

use GRAPE::Formats::Fasta ('check_fasta_file');
use GRAPE::Formats::GFF ('check_gff_file');

##################################################
## This should manage the options generated by the start script
##################################################
sub new {
    my $class =shift;
    my $tables=shift;
    
    my $self  = {};
    bless($self,$class);
    
    my %options;
    my $success=GetOptions(\%options,
			   'species|s=s',
			   'project=s',
			   'experiment=s',
			   'clean',
			   'help|h',
			   'man',
			   'debug|d+',
			   'template|t=s',
			   'annotation|a=s',
			   'genome|g=s',
			   'files=s',
			   'host=s',
			   'commondb=s',
			   'database=s',
			   'geneclass=s',
			   'transclass=s',
			   'junctionstable=s',
			   'junctionsclass=s',
			   'exonsclass=s',
			   'mismatches=i',
			   'paired',
			   'stranded',
			   'readlength=i',
			   'mapper=s',
			   'threads=i',
			   'genomeindex=s',
			   'transcriptomeindex=s',
			   'junctionsindex=s',
			   'exclusionfile=s',
			   'localdir=s',
			   'cluster=s',
			   'qualities=s',
			   'cellline=s',
			   'compartment=s',
			   'run_description=s',
			   'projdesc=s',
			   'rnafrac=s',
			   'bioreplicate=s',
			   'preprocess=s',
			   'preprocess_trim_length=s',
			   'fluxmem=i',
			   'genomeassembly=s',
			   'genomesource=s',
			   'gender=s',
			   'annotationversion=s',
			   'annotationsource=s'
	);

    # Determine if the options were all read correctly
    $self->set_OptionsOK($success);

    # Initialize the options that need to be present with the provided values or
    # reasonable defaults if they are missing
    $self->_initialize(\%options);

    # Determine if there were additional parameters that were not options. If
    # so, these should be files
    if (@ARGV) {
	$self->set_files(@ARGV);
    }

    # Add those parameters that are dependent on the provided values
    if ($tables) {
	_add_extra_parameters($self,
			      $tables);
    }

#    _guess_missing_values($self);

    return $self;
}

sub set_files {
    my $self=shift;
    my @files=@_;

    # Check if we can guess from the files what they are
    if (@files == 1) {
	# These are single
	my $file=shift @files;
	print STDERR "Assuming single end reads for $file\n";
    } elsif (@files == 2) {
	# These are likely to be paired
	print STDERR "Assuming paired end reads for:\n";
	print STDERR join("\t",@files),"\n";
	$self->{'paired'}=1;
    } else {
	die "Unable to decide if input read files are paired or not\n";
    }
    return($self)
}

sub set_commondb {
    my $self=shift;
    my $value=shift;

    my $dbh=MySQL_DB_Connect($value);
    $self->{'commondbh'}=$dbh;
    $self->{'commondb'}=$value;

    return($self);
}

sub set_database {
    my $self=shift;
    my $value=shift;

    my $dbh=MySQL_DB_Connect($value);
    $self->{'dbh'}=$dbh;
    $self->{'database'}=$value;

    print STDERR "Here";

    return($self);
}

sub _add_extra_parameters {
    my $self=shift;
    my $tables=shift;

    $self->{'proj_prefix'}=join('_',
				$self->{'project'},
				$self->{'experiment'});
    $self->{'CommonTables'}=$tables;

    # Set the species tables
    $self->set_species_tables();

    # Set the genome tables, which depend on the species tables
    $self->set_genome_tables();

    # Set the annotation tables, which depend on species and genome
    $self->set_annotation_tables();

    # Set the exclusion files table
    $self->set_exclusion_tables();

    # Set the fasta files table
    $self->set_fasta_files_tables();

    # Set the indices table

    # Set the protocol info table

    # Set the projects table

    # set the experiments table

    return($self);
}

sub _guess_missing_values {
    my $self=shift;

    my $dbh=$self->get_commondbh();

    foreach my  $opt (keys %{$self}) {
	if (defined $self->{$opt}) {
	    print STDERR $opt,"\tDefined as ",$self->{$opt},"\n";
	} else {
	    print STDERR $opt,"\tUndefined\n";
	    my $subname='guess_'.$opt;
	    $self->$subname($opt);
	    print STDERR "Setting to:",$self->{$opt},"\n";
	}
    }

    return($self);
}

sub print_options {
    my $self=shift;
    my $missing=shift;

    foreach my $opt (sort keys %{$self}) {
	if ($missing && $self->{$opt}) {next;} 
	my $val=$self->{$opt} || '-';
	print join("\t",
		   uc($opt),
		   $val),"\n";
    }
}

sub _initialize {
    my $self=shift;
    my $options=shift;

    # Set each of the defined options
    foreach my $option (keys %{$options}) {
	my $subname='set_'.$option;
	$self->$subname($options->{$option});
    }

    $self->{'species'} = undef unless $self->{'species'};
    $self->set_project(undef) unless $self->get_project();
    $self->set_experiment(undef) unless $self->get_experiment();
    $self->{'template'} = 'template.txt' unless $self->{'template'};
    $self->{'annotation'} = undef unless $self->{'annotation'};
    $self->set_genome(undef) unless $self->get_genome();
    $self->{'files'} = 'read.list.txt' unless $self->{'files'};
    $self->{'host'} = 'localhost' unless $self->{'host'};
    $self->set_commondb('TestRNAseqPipelineCommon') unless $self->get_commondb();
    $self->set_database('TestRNAseqPipeline') unless $self->get_database();
    $self->{'mismatches'} = 2 unless $self->{'mismatches'};
    $self->{'stranded'} = 0 unless $self->{'stranded'};
    $self->{'readlength'} = undef unless $self->{'readlength'};
    $self->{'mapper'} = 'GEM' unless $self->{'mapper'};
    $self->{'threads'} = 2 unless $self->{'threads'};
    $self->{'localdir'} = undef unless $self->{'localdir'};
    $self->{'cluster'} = '-' unless $self->{'cluster'};
    $self->{'qualities'} = 'ignore' unless $self->{'qualities'};
    $self->{'preprocess'} = '' unless $self->{'preprocess'};
    $self->{'preprocess_trim_length'} = 0 unless $self->{'preprocess_trim_length'};
    $self->{'input'} = 'fastqc' unless $self->{'input'};
    $self->set_projectdir() unless $self->{'projectdir'};
    $self->set_indexdir() unless $self->{'indexdir'};

    return $self;
}

sub set_projectdir {
    my $self=shift;

    my $project_dir=getcwd();
    chomp($project_dir);
    $self->{'projectdir'}=$project_dir;

    return($self);
}

sub set_indexdir {
    my $self=shift;

    my $project_dir=$self->get_projectdir();
    $self->{'indexdir'}=$project_dir."/GEMIndices";

    return($self);
}

sub guess_localdir {
    my $self=shift;

    my $project_dir=getcwd();
    chomp($project_dir);
    $self->{'localdir'}=$project_dir."/work";

    return($self);
}

# This should set the experiment value and also insert it in the necessary
# tables
sub set_experiment {
    my $self=shift;
    my $value=shift || die "No experiment ID has been provided\n";

    if ($value=~/([^\w_])/o) {
	my $char=$1;
	warn "WARNING: Experiment value $value contains an invalid character: '$char'\n";
    }

    $self->{'experiment'} = $value;

    return($self);
}

# This should set the project value and also insert it in the correct tables
sub set_project {
    my $self=shift;
    my $value=shift || die "No project ID has been provided\n";

    if ($value=~/([^\w_])/o) {
	my $char=$1;
	warn "WARNING: Project value $value contains an invalid character: '$char'\n";
    }

    $self->{'project'} = $value;

    return($self);
}

sub set_qualities {
    my $self=shift;
    my $value=shift;

    unless ($value=~/(solexa|phred|ignore)$/o) {
	my $char=$1;
	warn "WARNING: Qualities value $value contains an invalid character: '$char'\n";
    }

    return $self->{'qualities'} = $value;
}

sub set_preprocess_trim_length {
    my $self=shift;
    my $value=shift;

    unless ($value=~/^(<?=?(\d)+)$/o) {
	my $char=$1;
	warn "WARNING: Qualities value $value contains an invalid character: '$char'\n";
    }
    
    $self->{'preprocess_trim_length'} = $value;

    return($self);
}


sub set_genome {
    my $self=shift;
    my $file=shift;

    unless (-r $file) {
	warn "WARNING: Genome file supplied is not readable: $!\n";
    }
    
    return $self->{'genome'} = $file;
}
# Set the information dependent on the species
sub set_species_tables {
    my $self=shift;
    my $species=$self->get_species();

    # Annotation tables: Depend only on species
    my $table='species_info';
    my $type='species';
    my $field='species_id';
    my $dbh=$self->get_commondbh() || die "Unknown dbh\n";

    my ($query,$sth,$species_id);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);
    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$species],
			   $table,
			   $field);
    
    my $count=$sth->execute($species);
    if ($count == 1) {
	# The entry is present
	($species_id)=$sth->execute($species);
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $species is present more than once in $table\n";
    } else {
	# The entry is absent and we must set it
	# Get the genus and abbreviation
	my ($genus,$specific)=split(/\s+/,$species,2);
	my $abbreviation=join('',
			      substr($genus,0,1),
			      substr($specific,0,3));
	
	# Insert the info into the database
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET species = ? , genus = ? , abbreviation = ?, sp_alias = ? ';
	print STDERR "Executing: $query\n";
	my $sth2=$dbh->prepare($query);
	$sth2->execute($species,$genus,$abbreviation,'-');
    }
    # Get the Id of the value we just inserted
    $sth->execute($species);
    ($species_id)=$sth->fetchrow_array();

    $self->{'species_id'} = $species_id;
}

sub set_genome_tables {
    my $self=shift;
    my $location=$self->get_genome();
    my $genome=$location;
    $genome=~s/.*\///;

    my $species_id=$self->get_species_id();
    my $species=$self->get_species();

    # Genome tables: Depend only on genome and species
    my $table='genome_files';
    my $type='genome';
    my $field='genome_id';
    my $dbh=$self->get_commondbh() || die "Unknown dbh\n";
    my ($query,$sth,$genome_id);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);
    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$genome],
			   $table,
			   $field);
    
    my $count=$sth->execute($genome);
    if ($count == 1) {
	# The entry is present
	($genome_id)=$sth->execute($genome);
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $genome is present more than once in $table\n";
    } else {
	unless (-r $location) {
	    warn "WARNING: Genome file supplied is not readable: $!\n";
	}
    
	# First check if the fasta files is ok
	my $fileok=check_fasta_file($location);
	unless ($fileok) {
	    die "There is a problem with the genome file, so I'm quitting. Please check it\n";
	}

	# Fill in some possible extra arguments
	my $genomeassembly=$self->get_genomeassembly() || '\N';
	my $genomesource=$self->get_genomesource() || '\N';
	my $gender=$self->get_gender() || '\N';
    
	# The entry is absent and we must set it
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET genome= ? , species_id= ? , location= ? ,';
	$query.='assembly= ? , source= ? , gender= ? ';
	print STDERR "Executing: $query\n";
	my $sth2=$dbh->prepare($query);
	$sth2->execute($genome,$species,$location,
		       $genomeassembly,$genomesource,$gender);
    }

    # Get the Id of the value we just inserted
    $sth->execute($genome);
    ($genome_id)=$sth->fetchrow_array();

    $self->{'genome_id'} = $genome_id;
}

# Set the information dependent on the annotation
sub set_annotation_tables {
    my $self=shift;
    my $location=$self->get_annotation();
    my $annotation=$location;
    $annotation=~s/^.*\///;

    my $species_id=$self->get_species_id();
    my $species=$self->get_species();
    my $genome_id=$self->get_genome_id();

    # Annotation tables: Depend on species genome and annotation
    my $table='annotation_files';
    my $type='annotation';
    my $field='annotation_id';
    my $dbh=$self->get_commondbh() || die "Unknown dbh\n";
    my ($query,$sth,$annotation_id);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   [$type,$annotation],
			   $table,
			   $field);
    
    my $count=$sth->execute($annotation);
    if ($count == 1) {
	# The entry is present
	($annotation_id)=$sth->fetchrow_array();
    } elsif ($count > 1) {
	# There is a problem
	die "Entry $annotation is present more than once in $table\n";
    } else {
	unless (-r $location) {
	    warn "WARNING: Annotation file supplied is not readable: $!\n";
	}
	# First check the file to see if it conforms to the UCSC gff format
	my $fileok=check_gff_file($location);
	unless ($fileok) {
	    die "There is a problem with the genome file, so I'm quitting. Please check it\n";
	}

	# Fill in some possible extra arguments
	my $annotationversion=$self->get_annotationversion() || '\N';
	my $annotationsource=$self->get_annotationsource() || '\N';
	
	# The entry is absent and we must set it
	my $query;
	$query ="INSERT INTO $table ";
	$query.='SET annotation= ? , species_id= ? , location= ? ,';
	$query.='version= ? , source= ? ';
	my $sth2=$dbh->prepare($query);
	$sth2->execute($annotation,$species,$location,
		       $annotationversion,$annotationsource);
    }
    # Get the Id of the value we just inserted
    $sth->execute($annotation);
    ($annotation_id)=$sth->fetchrow_array();

    $self->{'annotation_id'} = $annotation_id;

    # Now build the annotation table: It depends only on annotation and genome
    _fill_annotation_table($self,
			   'exonsclass');
    _fill_annotation_table($self,
			   'transclass');
    _fill_annotation_table($self,
			   'geneclass');
    _fill_annotation_table($self,
			   'junctionsclass');
    _fill_annotation_table($self,
			   'junctionstable');
}

sub _fill_annotation_table {
    my $self=shift;
    my $type=shift;

    my $table='annotation_tables';
    my $annotation_id=$self->get_annotation_id();
    my $genome_id=$self->get_genome_id();
    my $dbh=$self->get_commondbh();
    my $annotation=$self->get_annotation();

    my %suffix=('junctionsclass' => 'junctclass',
		'exonsclass' => 'exclass',
		'junctionstable' => 'junct');

    # Check if the table exists and create it if it does not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    my ($query,$sth,$count,$table_name);
    $query ='SELECT table_name ';
    $query.="FROM $table ";
    $query.='WHERE annotation_id = ? AND type = ?';
    $sth=$dbh->prepare($query);

    # Set or get the information on the naming of the annotation tables that
    # correspond to the genome and annotation we are looking at.
    # Get the common sth for this table    
    $count=$sth->execute($annotation_id,$type);
    if ($count > 0) {
	if ($count == 1) {
	    ($table_name)=$sth->fetchrow_array();
	} else {
	    die "More than one $table entry retrieved for $annotation\n";
	}
    } else {
	# get the required information from the annotation
	my $annot_string=$annotation;
	$annot_string=~s/.*\///;
	$annot_string=substr($annot_string,0,30);
	$table_name=$annotation_id.'_'.$annot_string;
	$table_name.='_'.($suffix{$type} || $type);
	$table_name=~s/\./_/g;
	print STDERR "Table entry not present. Will be built in $table_name\n";

	# The table is not present so we will fil into the database the 
	# location where it will be built
	my ($ins_query,$ins_sth);
	$ins_query ="INSERT INTO $table ";
	$ins_query.='SET genome_id = ?,annotation_id = ?,';
	$ins_query.='type = ?,table_name = ?';
	$ins_sth=$dbh->prepare($ins_query);

	# The entry is absent and we must set it
	print STDERR "Executing: $ins_query\n";
	$ins_sth->execute($genome_id,$annotation_id,
			  $type,$table_name);
    }
    $self->{$type}=$table_name;
}

sub set_exclusion_tables {
    my $self=shift;
    my $annotation_id=$self->get_annotation_id();
    my $species_id=$self->get_species_id();
    my $annotation=$self->get_annotation();
    my $dbh=$self->get_commondbh();
    my $project_dir=$self->get_projectdir();
    my $table='exclusion_files';
    my ($query,$sth,$exclusion_id,$exclusionfile);

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Exclusion query: depends only on annotation
    # Check if the value is already defined
    $sth=check_field_value($dbh,
			   ['annotation_id',$annotation_id],
			   $table,
			   'location');

    # Get the exclusion file if present or set the location to build it if
    # absent
    my $count=$sth->execute($annotation_id);
    if ($count > 0) {
	if ($count == 1) {
	    ($exclusionfile)=$sth->fetchrow_array();
	} else {
	    warn "More than one $table entry retrieved for $annotation\n";
	}
    } else {
	# The entry is absent and we must set it
	$exclusionfile=$annotation;
	$exclusionfile=~s/.*\///;
	$exclusionfile=~s/\.g[tf]f//;
	$exclusionfile.='.exclusion';
	$exclusionfile=$project_dir.'/GEMIndices/'.$exclusionfile;
    
	print STDERR "File not present. Will be built at $exclusionfile\n";

	my ($ins_query,$ins_sth);
	$ins_query ="INSERT INTO $table ";
	$ins_query.='SET annotation_id = ?,species_id = ?,location = ?';
	print STDERR "Executing: $ins_query\n";
	$ins_sth=$dbh->prepare($ins_query);
	$ins_sth->execute($annotation_id,$species_id,$exclusionfile);
	$ins_sth->finish();
    }

    # Set the entry we just inserted
    $self->{'exclusionfile'} = $exclusionfile;
}

sub set_fasta_files_tables {
    my $self=shift;

    my $dbh=$self->get_commondbh();
    my $table='fasta_files';

    # Check if the table is present and create it if not
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	my $tables=$self->get_CommonTables();
	my $database=$self->get_commondb();
	create_MySQL_table($database,
			   $table,
			   $tables->{$table});
    }

    # Now build the fasta files table: It depends only on annotation and genome
    _fill_fasta_table($self,
		      'exonsfasta');
    _fill_fasta_table($self,
		      'junctionsfasta');
    _fill_fasta_table($self,
		      'transcriptomefasta');
}

sub _fill_fasta_table {
    my $self=shift;
    my $type=shift;

    my $table='fasta_files';
    my $annotation_id=$self->get_annotation_id();
    my $genome_id=$self->get_genome_id();
    my $annotation=$self->get_annotation();
    my $genome=$self->get_genome();
    my $dbh=$self->get_commondbh();
    my $indexdir=$self->get_indexdir();

    my %suffix=('exonsfasta' => 'exons.fa',
		'junctionsfasta' => 'junctions.fa',
		'transcriptomefasta' => 'transcripts.fa');

    # Check if the table exists and die it if it does not, as ift should
    # have been created in sub that calls this one
    my $present=check_table_existence($dbh,
				      $table);

    unless ($present) {
	die "$table is absent\n";
    }

    my ($query,$sth,$count,$fasta_name);
    $query ='SELECT file_name ';
    $query.="FROM $table ";
    $query.='WHERE annotation_id = ? AND genome_id = ? AND filetype = ?';
    $sth=$dbh->prepare($query);

    # Set or get the information on the naming of the annotation tables that
    # correspond to the genome and annotation we are looking at.
    # Get the common sth for this table    
    $count=$sth->execute($annotation_id,$genome_id,$type);
    if ($count > 0) {
	if ($count == 1) {
	    ($fasta_name)=$sth->fetchrow_array();
	} else {
	    die "More than one $table entry retrieved for $genome_id and $annotation_id\n";
	}
    } else {
	# Get the required information from the annotation and genome
	$genome=~s/.*\///;
	$annotation=~s/.*\///;
	my $fasta_name=$annotation.'.'.$genome;
	$fasta_name=~s/\.g[tf]f//g;
	$fasta_name=~s/\.fa(stq)?$//;
	$fasta_name.='.'.($suffix{$type} || $type);
	$fasta_name=$indexdir.'/'.$fasta_name;
	print STDERR "$type entry not present. Will be built in $fasta_name\n";

	# The entry is not present so we will fil into the database the 
	# location where the file will be built
	my ($ins_query,$ins_sth);
	$ins_query ="INSERT INTO $table ";
	$ins_query.='SET genome_id = ?,annotation_id = ?,';
	$ins_query.='filetype = ?,file_name = ?';
	$ins_sth=$dbh->prepare($ins_query);

	# The entry is absent and we must set it
	print STDERR "Executing: $ins_query\n";
	$ins_sth->execute($genome_id,$annotation_id,
			  $type,$fasta_name);
    }
    $self->{$type}=$fasta_name;
}

#sub set_genomeindex {
#    my $self=shift;
#    my $filetype=shift;
#    my $present=0;

#    my $table='indices';
#    my $project_dir=$self->get_projectdir();
#    my $fasta_name=$self->get_genome();
#    $fasta_name=~s/\.fa$//;
#    my $location=$project_dir.'/GEMIndices/'.$fasta_name;
    
#    my $count=$sth->execute($genome_id,0,'genome');
#    if ($count > 0) {
#	if ($count == 1) {
#	    ($location)=$sth1->fetchrow_array();
#	    $present=1;
#	} else {
#	    warn "More than one entry retrieved for $genome\n";
#	    $present=1
#	}
#    }
#    if ($present) {
#	print $log_fh "File present at $location\n";
#    } else {
#	print $log_fh "File not present. Will be built at $location\n";
#	# The entry is absent and we must set it
#	print $log_fh "Executing: $ins_query1 for $location\n";
#	$ins_sth1->execute($genome_id,0,$species_id,
#			   $filetype,$location);
#    }
#    return($location);
#};



sub AUTOLOAD {
    my $self = shift;
    return if ($AUTOLOAD =~ /DESTROY/); # don't mess with garbage collection

    if (($AUTOLOAD =~ /.*set_(\w+)/) and (@_)) {
	my $key=$1;
	my $value=shift;
	if ($value=~/([^\w_\/\. -])/o) {
	    my $char=$1;
	    warn "WARNING: Value $value corresponding to $key contains an invalid character: '$char'\n";
	}
	return $self->{$key} = $value;
    } elsif ($AUTOLOAD =~ /.*get_(\w+)/) {
	my $key=$1;
        return $self->{$key};
    } else {
	die "Bad method call $AUTOLOAD:$!\n";
    }
}


1;
